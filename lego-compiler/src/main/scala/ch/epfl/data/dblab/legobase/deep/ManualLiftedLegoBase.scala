package ch.epfl.data
package dblab.legobase
package deep

import scala.reflect.runtime.universe.{ typeTag => tag }
import scala.language.implicitConversions
import sc.pardis.utils.TypeUtils.{ pardisTypeToString => t2s }
import sc.pardis.types.PardisTypeImplicits._
import java.io.PrintStream
import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import ch.epfl.data.dblab.legobase.queryengine.push._

/** A polymorphic embedding cake containing manually lifted methods and classes */
trait ManualLiftedLegoBase extends OrderingOps with ManifestOps with sc.pardis.deep.scalalib.collection.RichIntOps with sc.pardis.deep.scalalib.ByteComponent with sc.pardis.deep.scalalib.collection.ContOps with sc.pardis.deep.scalalib.ScalaPredef { this: DeepDSL =>
  // TODO these methods should be automatically lifted using Purgatory
  object Console {
    def err: Rep[PrintStream] = consoleErr()
    def out: Rep[PrintStream] = consoleOut()
  }

  def consoleErr(): Rep[PrintStream] = ConsoleErr()
  def consoleOut(): Rep[PrintStream] = ConsoleOut()
  case class ConsoleErr() extends FunctionDef[PrintStream](None, "Console.err", List()) {
    override def rebuild(children: PardisFunArg*) = ConsoleErr()
  }
  case class ConsoleOut() extends FunctionDef[PrintStream](None, "Console.out", List()) {
    override def rebuild(children: PardisFunArg*) = ConsoleOut()
  }

  case class PrintStreamPrintf2(self: Rep[PrintStream], s: Rep[String], objsOutput: Rep[Any]*) extends FunctionDef[Unit](Some(self), "printf", List(s :: objsOutput.toList)) {
    override def rebuild(children: FunctionArg*) = PrintStreamPrintf2(children(0).asInstanceOf[Rep[PrintStream]], children(1).asInstanceOf[Rep[String]], children.drop(2).toSeq.asInstanceOf[Seq[Rep[Any]]]: _*)
  }
  override def printStreamPrintf(self: Rep[PrintStream], s: Rep[String], objs: Rep[Any]*): Rep[Unit] = {
    PrintStreamPrintf2(self, s, objs: _*)
  }

  def __newException(msg: Rep[String]) = new Exception(msg.toString)

  // TODO this thing should be removed, ideally every literal should be lifted using YY
  // or should be added to the Implicits cake of generated deep embedding of Int
  implicit def liftInt(i: scala.Int): Rep[Int] = unit(i)

  // TODO implicit parameters should be handled in a correct way to remove this manually lifted one
  def __newTreeSet2[A](ordering: Rep[Ordering[A]])(implicit typeA: TypeRep[A]): Rep[TreeSet[A]] = TreeSetNew2[A](ordering)(typeA)
  // case classes
  case class TreeSetNew2[A](val ordering: Rep[Ordering[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[TreeSet[A]](None, "new TreeSet", List(Nil, List(ordering))) {
    override def curriedConstructor = (copy[A] _)
  }

  // this one is needed to rewrire `ArrayBuffer.apply()` to `new ArrayBuffer()`
  // TODO Purgatory should handle that
  override def arrayBufferApplyObject[A](elems: Rep[A]*)(implicit typeA: TypeRep[A]): Rep[ArrayBuffer[A]] =
    if (elems.size == 0)
      __newArrayBuffer[A]()
    else
      this.arrayBufferApplyObject(elems: _*)

  /* TODO there's a bug with the design of records which if it's solved there's no need for this manual node */
  override def aGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = AGGRecordNew2[B](key, aggs)
  case class AGGRecordNew2[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit val typeB: TypeRep[B]) extends ConstructorDef[AGGRecord[B]](List(), "AGGRecord", List(List(key, aggs))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  // TODO should be handled by Purgatory by adding more annotations
  override def __newRange(start: Rep[Int], end: Rep[Int], step: Rep[Int]): Rep[Range] = step match {
    case Constant(1) => Range(start, end)
    case _           => super.__newRange(start, end, step)
  }

  // TODO may be should be moved to SC?
  def array_foreach[T: TypeRep](arr: Rep[Array[T]], f: Rep[T] => Rep[Unit]): Rep[Unit] = {
    Range(unit(0), arr.length).foreach {
      __lambda { i =>
        val e = arr(i)
        f(e)
      }
    }
  }

  // TODO should be automatically generated by Purgatory
  def byteArrayOps(arr: Rep[Array[Byte]]): Rep[Array[Byte]] = arr
}

// TODO needs lifting type classes
trait OrderingOps { this: DeepDSL =>
  object Ordering {
    def apply[T: TypeRep](comp: Rep[Function2[T, T, Int]]): Rep[Ordering[T]] = OrderingNew(comp)
  }
  case class OrderingNew[T: TypeRep](comp: Rep[Function2[T, T, Int]]) extends FunctionDef[Ordering[T]](None, "OrderingFactory", List(List(comp))) {
    override def curriedConstructor = copy[T] _
  }
  object OrderingRep {
    def apply[T: TypeRep]: Rep[Ordering[T]] = OrderingNew2[T]()
  }
  case class OrderingNew2[T]()(implicit typeT: TypeRep[T]) extends FunctionDef[Ordering[T]](None, s"Ordering[${t2s(typeT)}]", Nil) {
    // override def curriedConstructor = copy[T] _
    override def rebuild(children: PardisFunArg*) = OrderingNew2[T]()
    override def isPure = true
  }

  implicit class OrderingOps[T: TypeRep](cmp: Rep[Ordering[T]]) {
    def lt(lhs: Rep[T], rhs: Rep[T]) = ordering_lt(lhs, rhs)
  }
  def ordering_lt[T: TypeRep](lhs: Rep[T], rhs: Rep[T]): Rep[Boolean] = OrderingLT(lhs, rhs)
  case class OrderingLT[T: TypeRep](lhs: Rep[T], rhs: Rep[T]) extends FunctionDef[Boolean](Some(lhs), s"<", List(List(rhs))) {
    override def curriedConstructor = (copy[T] _).curried
  }
}

// TODO needs lifting type classes
trait ManifestOps { this: DeepDSL =>
  object ManifestRep {
    def apply[T: TypeRep](man: Manifest[T]): Rep[Manifest[T]] = ManifestNew[T](man)
  }

  case class ManifestNew[T](man: Manifest[T])(implicit typeT: TypeRep[T]) extends FunctionDef[Manifest[T]](None, s"manifest[${t2s(typeT)}]", Nil) {
    override def curriedConstructor = copy[T] _
  }
}
